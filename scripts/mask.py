import argparse
from numpy import arange, sin, cos, full, ceil, savetxt, tile

# Parse command line arguments
parser = argparse.ArgumentParser(
    description='Generate mask for given files of ellipses generated by CIAO')
parser.add_argument('maskFiles', nargs='+',
                    help='List of paths to files of ellipses to mask')
parser.add_argument(
    '-s', '--size', help='Size of region being processed, in pixels', type=int, default=8192)
parser.add_argument('-d', '--overdraw',
                    help='Positive values increase effective radius of ellipse, negative decrease.', type=float, default=0)
parser.add_argument('-o', '--outputFile', help='Path to output file',
                    type=argparse.FileType('w'), default='mask.txt')
args = parser.parse_args()


class Ellipse:
    """Ellipse definition."""
    def __init__(self, x, y, radius1, radius2, angle):
        super().__init__()
        self.x = x
        self.y = y
        self.radius1 = radius1
        self.radius2 = radius2
        self.angle = angle # Radians

    def generate_matrix(self, overdraw=0):
        """Create a square array of 0 and 1, with 1 representing the shape of the ellipse."""

        radius = max(self.radius1, self.radius2) + 1 # Add one to ensure we don't miss anything on the edge.
        r = arange(-radius, radius+1, 1) # Add 1 to account for Python's range end behaviour (last element of 1:10 is 9, etc)

        x = tile(r, (len(r), 1)) # Create matrix of x values for each point
        y = x.T # Create same matrix for y values

        # For every point check if in ellipse. If so, set to 1.
        return (x*cos(self.angle) + y*sin(self.angle)) ** 2 / self.radius1 ** 2 + \
            (x*sin(self.angle) - y *
             cos(self.angle)) ** 2 / self.radius2 ** 2 <= (1 + overdraw)


def coord2index(x, y, zeroIndex=(0.5, 0.5)):
    """
    Convert a coordinate to index.

    Intended to handle input coordinates that don't algin with matrix coordinates due to origin position.
    Default value align coordinates (0.5, 0.5) to indices (1,1).
    """

    # Adds zero index to each coordinate and rounds up
    return [int(ceil(i+j)) for i, j in zip((x, y), zeroIndex)]

# Convert lines of ellipse definitions in input file to a list of Ellipse objects.
print("Loading ellipses.")
ellipses = []
for filePath in args.maskFiles:
    with open(filePath, 'r') as f:
        for line in f:
            line = line.strip()
            # Currently assuming pixel coordinates. In theory this isn't guaranteed.
            x, y, r1, r2, angle = [
                float(el.strip(' )')) for el in line.split('(')[1].split(',')]
            ellipses.append(Ellipse(x, y, r1, r2, angle))

# Print ellipses on a matrix
print("Generating mask array.")
# Generate matrix of zeros (no masking) covering the entire region of data
mask = full((args.size, args.size), False)

for el in ellipses:
    # Convert ellipse into matrix
    elM = el.generate_matrix(args.overdraw)

    # Get indices to place the ellipse on the mask matrix
    radius = elM.shape[1] / 2
    x0, y0 = coord2index(el.x-radius, el.y-radius)
    x1, y1 = coord2index(el.x+radius, el.y+radius)

    # If the ellipse goes off the edge of the region crop it
    if x0 < 0: # Left
        elM = elM[-x0:, :]
        x0 = 0
    if y0 < 0: # Top
        elM = elM[:, -y0:]
        y0 = 0
    if x1 > args.size: # Right
        elM = elM[:-(x1-args.size), :]
        x1 = args.size
    if y1 > args.size: # Bottom
        elM = elM[:, :-(y1-args.size)]
        y1 = args.size

    # Add matrix on mask by numpy.logical_or
    mask[x0:x1, y0:y1] = mask[x0:x1, y0:y1] | elM

print('Exporting array to file.')
savetxt(args.outputFile, mask, fmt='%.1d')
print('File saved as {}.'.format(args.outputFile.name))
