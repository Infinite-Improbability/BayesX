#!/usr/bin/env python3

import argparse
import numpy as np

# Parse command line arguments
parser = argparse.ArgumentParser(
    description='Generate mask for given files of ellipses generated by CIAO')

bounds = parser.add_argument_group('bounds', 'Coordinates of data bounds.')
bounds.add_argument('xMin', type=float, help='Minimum x coordinate in data.')
bounds.add_argument('yMin', type=float, help='Minimum y coordinate in data.')
bounds.add_argument('xMax', type=float, help='Maximum x coordinate in data.')
bounds.add_argument('yMax', type=float, help='Maximum x coordinate in data.')

parser.add_argument('maskFiles', nargs='+',
                    help='List of paths to files of ellipses to mask')

# Optional
parser.add_argument('-d', '--overdraw',
                    help='Positive values increase effective radius of ellipse, negative decrease.', type=float, default=0)
parser.add_argument('-o', '--outputFile', help="""Path to output file. File extensions '.txt' and '.txt.gz' will export to a text file,
                                                with compression in the latter case. This is slowest and large. Best for human readable output.
                                                '.npy' will export to an uncompressed numpy .npy file. This is the fastest option but large.
                                                '.npz' (default) will export to a compressed numpy .npz file. This is slower than .npy but much smaller.
                                                """,
                    type=argparse.FileType('wb'), default='mask.npz')
args = parser.parse_args()

size = (int(args.xMax-args.xMin), int(args.yMax-args.yMin))
# TODO: Custom step size support. Currently assumes step of 1.


class Ellipse:
    """Ellipse definition."""

    def __init__(self, x, y, radius1, radius2, angle):
        super().__init__()
        self.x = x
        self.y = y
        self.radius1 = radius1
        self.radius2 = radius2
        self.angle = angle  # Radians

    def generate_matrix(self, overdraw=0):
        """Create a square array of 0 and 1, with 1 representing the shape of the ellipse."""

        # Add one to ensure we don't miss anything on the edge.
        radius = max(self.radius1, self.radius2) + 1
        # Add 1 to account for Python's range end behaviour (last element of 1:10 is 9, etc)
        r = np.arange(-radius, radius+1, 1)

        x = np.tile(r, (len(r), 1))  # Create matrix of x values for each point
        y = x.T  # Create same matrix for y values

        # For every point check if in ellipse. If so, set to 1.
        return (x*np.cos(self.angle) + y*np.sin(self.angle)) ** 2 / self.radius1 ** 2 + \
            (x*np.sin(self.angle) - y *
             np.cos(self.angle)) ** 2 / self.radius2 ** 2 <= (1 + overdraw)


def coord2index(x, y, referenceCoordinates=(args.xMin, args.yMin)):
    """
    Convert a coordinate to index.

    Intended to handle input coordinates that don't align with matrix coordinates due to origin position.
    Aligns referenceCoordinates to index [0,0]. Reference coordinates should be (xMin, yMin.)
    """

    # Adds zero index to each coordinate and rounds
    # TODO: Needs confirmation of correct rounding behaviour.
    return [int(round(coord-ref)) for coord, ref in zip((x, y), referenceCoordinates)]


# Convert lines of ellipse definitions in input file to a list of Ellipse objects.
print("Loading ellipses.")
ellipses = []
for filePath in args.maskFiles:
    with open(filePath, 'r') as f:
        for line in f:
            line = line.strip()
            # Currently assuming pixel coordinates. In theory this isn't guaranteed.
            x, y, r1, r2, angle = [
                float(el.strip(' )')) for el in line.split('(')[1].split(',')]
            ellipses.append(Ellipse(x, y, r1, r2, angle))

# Print ellipses on a matrix
print("Generating mask array.")
# Generate matrix of zeros (no masking) covering the entire region of data
mask = np.full(size, False)

for el in ellipses:
    # Convert ellipse into matrix
    elM = el.generate_matrix(args.overdraw)

    # Get indices to place the ellipse on the mask matrix
    radius = elM.shape[1] / 2
    x0, y0 = coord2index(el.x-radius, el.y-radius)
    x1, y1 = coord2index(el.x+radius, el.y+radius)

    # If the ellipse goes off the edge of the region crop it
    if x0 < 0:  # Left
        elM = elM[-x0:, :]
        x0 = 0
    if y0 < 0:  # Top
        elM = elM[:, -y0:]
        y0 = 0
    if x1 > size[0]:  # Right
        elM = elM[:-(x1-size[0]), :]
        x1 = size[0]
    if y1 > size[1]:  # Bottom
        elM = elM[:, :-(y1-size[1])]
        y1 = size[1]

    # Add matrix on mask by numpy.logical_or
    mask[x0:x1, y0:y1] = mask[x0:x1, y0:y1] | elM

print('Preparing array for export.')
# Rearrange for export
x = np.tile(np.arange(args.xMin, args.xMax), size[1])   # [1,2,3,1,2,3,...]
y = np.repeat(np.arange(args.yMin, args.yMax), size[0])  # [1,1,1,2,2,2,...]
mask1D = np.column_stack((x, y, np.ravel(mask)))
# Don't need to export umasked regions
mask1D = mask1D[mask1D[:,2] == 1]

filename_parts = args.outputFile.name.strip().split('.')
file_type = filename_parts[-1]


if file_type == 'gz':
    file_type = filename_parts[-2]
if file_type == 'txt':
    print('Exporting to .txt file.')
    np.savetxt(args.outputFile, mask1D, fmt=['%.10g', '%.10g', '%.1d'])
elif file_type == 'npy':
    print('Exporting to .npy file.'.format(file_type))
    np.save(args.outputFile, mask1D)
else:
    print('Exporting to compressed .npz file.')
    np.savez_compressed(args.outputFile, mask1D)

print('File saved as {}.'.format(args.outputFile.name))
